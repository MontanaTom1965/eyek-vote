<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>EYEK ‚Ä¢ Host</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body{font-family:system-ui,Segoe UI,Arial,sans-serif;background:#0a0c10;color:#e6eef8;margin:0}
    header{display:flex;gap:12px;align-items:center;padding:12px 16px;background:#121621;border-bottom:1px solid #1d2433}
    .wrap{display:grid;grid-template-columns:320px 1fr;gap:16px;padding:16px}
    aside{background:#0f1320;border:1px solid #1d2433;border-radius:12px;padding:12px;max-height:calc(100dvh - 110px);overflow:auto}
    main{background:#0f1320;border:1px solid #1d2433;border-radius:12px;padding:16px}
    h2{margin:8px 0 12px;font-size:18px}
    .row{display:flex;gap:10px;align-items:center;margin:8px 0}
    input,button{font-size:16px}
    input[type="text"],input[type="number"]{background:#0b0f1a;border:1px solid #23304a;color:#e6eef8;border-radius:8px;padding:10px}
    button{background:#1e2a44;color:#e6eef8;border:1px solid #35476a;border-radius:10px;padding:10px 14px;cursor:pointer}
    button:hover{background:#263659}
    .danger{background:#3a1620;border-color:#6b2336}
    .success{background:#16351f;border-color:#2e6b42}
    details{background:#0b1020;border:1px solid #1d2433;border-radius:10px;padding:10px;margin-bottom:12px}
    summary{cursor:pointer;font-weight:600}
    .pill{display:inline-flex;gap:6px;align-items:center;border:1px solid #2a3550;background:#11182a;border-radius:999px;padding:6px 10px;font-size:13px}
    .list{display:flex;flex-direction:column;gap:6px;margin-top:8px}
    .item{display:flex;align-items:center;justify-content:space-between;background:#0b0f1a;border:1px solid #1f2a44;border-radius:10px;padding:8px 10px}
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.green{background:#1dd05d}.dot.yellow{background:#f9d64a}.dot.gray{background:#6b7a96}.dot.red{background:#ff5d7a}
    .small{font-size:12px;color:#9fb0cf}
    .flex{display:flex;gap:8px;align-items:center}
    .grow{flex:1}
    .right{margin-left:auto}
    .muted{opacity:.8}
    .stack{display:grid;gap:8px}
    .section{border-top:1px dashed #23304a;margin-top:12px;padding-top:12px}
  </style>
</head>
<body>
<header>
  <div class="pill">Host Console</div>
  <div id="eventBadge" class="pill"></div>
  <div id="lockBadge" class="pill"></div>
  <div class="right small" id="statusLine">loading‚Ä¶</div>
</header>

<div class="wrap">
  <aside>
    <h2>Rotation</h2>
    <div class="small muted">Click ‚ñ∂ to set ‚ÄúCurrent‚Äù. Red trash removes. Green/yellow dots show last result.</div>
    <div id="singerList" class="list"></div>
  </aside>

  <main>
    <details id="eventPanel">
      <summary>Event ‚Ä¢ Venue & KJ & PIN (save together)</summary>
      <div class="stack section">
        <div class="row">
          <input class="grow" id="venue" placeholder="Venue name"/>
          <input class="grow" id="kj" placeholder="KJ name"/>
          <input style="width:140px" id="pin" type="number" placeholder="PIN (digits)"/>
        </div>
        <div class="row">
          <button id="saveEvent" class="success">Save Event / KJ / PIN</button>
          <button id="toggleLock">Lock</button>
          <button id="resetEvent" class="danger">Reset Event</button>
        </div>
      </div>
    </details>

    <section class="section">
      <h2>Add Singer</h2>
      <div class="row">
        <input class="grow" id="singer" placeholder="Singer"/>
        <input class="grow" id="songArtist" placeholder="Song / Artist"/>
        <button id="addSinger">Add</button>
      </div>
    </section>

    <section class="section">
      <h2>Current & Voting</h2>
      <div class="row">
        <div id="nowPlaying" class="pill">No singer set</div>
        <div id="voteClock" class="pill">Timer: --</div>
        <button id="startVote" class="success">Start 30s Vote</button>
        <button id="extendVote">Extend +15s</button>
        <button id="endVote" class="danger">End Vote</button>
      </div>
      <div class="row">
        <span class="small muted">Host Vote:</span>
        <button data-mark="Encore" class="markBtn success">Encore!</button>
        <button data-mark="Another Shot" class="markBtn">Another Shot!</button>
        <button data-mark="Maybe Next Time" class="markBtn danger">Maybe Next Time!</button>
      </div>
    </section>
  </main>
</div>

<script>
const STORE_URL = '/assets/status.json';
const SAVE_URL  = '/assets/save.php';
let cache = null;
let typing = {}; // prevent wiping fields while typing
let clockTimer = null;

const qs = sel => document.querySelector(sel);
const elVenue = qs('#venue'), elKJ = qs('#kj'), elPIN = qs('#pin');
const elSaveEvent = qs('#saveEvent'), elToggleLock = qs('#toggleLock'), elReset = qs('#resetEvent');
const elSinger = qs('#singer'), elSongArtist = qs('#songArtist'), elAdd = qs('#addSinger');
const elList = qs('#singerList'), elNow = qs('#nowPlaying'), elClock = qs('#voteClock');
const elStart = qs('#startVote'), elExtend = qs('#extendVote'), elEnd = qs('#endVote');
const statusLine = qs('#statusLine'), lockBadge = qs('#lockBadge'), eventBadge = qs('#eventBadge');

['#venue','#kj','#pin','#singer','#songArtist'].forEach(sel=>{
  qs(sel).addEventListener('input', ()=> typing[sel]=true);
});

// Fetch state
async function load() {
  const res = await fetch(STORE_URL + '?_=' + Date.now());
  cache = await res.json();
  render();
}
function dot(color){ return `<span class="dot ${color}"></span>`; }

function render(){
  // badges
  eventBadge.textContent = (cache.event.venue||'(set venue)') + ' ‚Ä¢ ' + (cache.event.kj||'(set KJ)');
  lockBadge.innerHTML = (cache.event.locked ? dot('green')+' Locked' : dot('yellow')+' Unlocked');

  // form (respect typing)
  if (!typing['#venue']) elVenue.value = cache.event.venue || '';
  if (!typing['#kj']) elKJ.value = cache.event.kj || '';
  if (!typing['#pin']) elPIN.value = cache.event.pin || '';

  // rotation
  elList.innerHTML = '';
  (cache.singers||[]).forEach((s, idx)=>{
    const color = s.last === 'Encore' ? 'green' : s.last === 'Another Shot' ? 'yellow' : s.last === 'Maybe Next Time' ? 'red' : 'gray';
    const row = document.createElement('div');
    row.className = 'item';
    row.innerHTML = `
      <div class="flex">
        <span class="dot ${color}"></span>
        <strong>${s.name}</strong>
        <span class="small muted">&nbsp;${s.songArtist ? '‚Ä¢ '+escapeHtml(s.songArtist): ''}</span>
      </div>
      <div class="flex">
        <button data-act="play" data-idx="${idx}">‚ñ∂</button>
        <button data-act="rm" data-idx="${idx}" class="danger">üóë</button>
      </div>
    `;
    row.addEventListener('click', (e)=>{
      const act = e.target.getAttribute('data-act');
      const i = +e.target.getAttribute('data-idx');
      if (act === 'rm') removeSinger(i);
      if (act === 'play') setCurrent(i);
    });
    elList.appendChild(row);
  });

  // current
  if (cache.current && cache.current.singer) {
    elNow.textContent = `${cache.current.singer} ‚Äî ${cache.current.songArtist||''}`.trim();
  } else {
    elNow.textContent = 'No singer set';
  }

  // clock
  tickClock();

  statusLine.textContent = 'Updated: ' + new Date(cache.lastChange*1000).toLocaleTimeString();
}

function tickClock(){
  if (clockTimer) clearInterval(clockTimer);
  function draw(){
    const now = Date.now();
    const end = (cache.current?.voteEndsAt || 0) * 1000;
    if (!end || end < now) { elClock.textContent = 'Timer: --'; return; }
    const sec = Math.max(0, Math.ceil((end - now)/1000));
    elClock.textContent = `Timer: ${sec}s`;
  }
  draw();
  clockTimer = setInterval(draw, 500);
}

async function save(patch){
  const payload = { pin: (qs('#pin').value||cache.event.pin||'').toString(), data: patch };
  const res = await fetch(SAVE_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
  const out = await res.json();
  if (!out.ok){ alert('Save failed: ' + (out.error||'unknown')); return; }
  cache = out.updated;
  typing = {};
  render();
}

function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

// actions
elSaveEvent.onclick = () => {
  save({ event:{
    venue: elVenue.value.trim(),
    kj: elKJ.value.trim(),
    pin: elPIN.value.trim(),
  }});
};
elToggleLock.onclick = () => save({ event:{ locked: !cache.event.locked }});
elReset.onclick = () => {
  if (!confirm('Reset this event? This clears venue/KJ/PIN, roster, current, and results.')) return;
  save({
    event:{ venue:'', kj:'', pin:'', locked:false, startedAt: 0 },
    current:{ singer:'', songArtist:'', status:'idle', voteEndsAt:0 },
    singers:[],
    results:[]
  });
};
elAdd.onclick = () => {
  const name = elSinger.value.trim();
  const sa = elSongArtist.value.trim();
  if (!name) return;
  const singers = (cache.singers||[]).slice();
  singers.push({ name, songArtist: sa, last:'' });
  elSinger.value = ''; elSongArtist.value = '';
  save({ singers });
};
async function removeSinger(i){
  const singers = (cache.singers||[]).slice();
  singers.splice(i,1);
  await save({ singers });
}
async function setCurrent(i){
  const s = (cache.singers||[])[i];
  if (!s) return;
  await save({ current:{ singer: s.name, songArtist: s.songArtist||'', status:'waiting', voteEndsAt: 0 }});
}
elStart.onclick = () => {
  const until = Math.floor(Date.now()/1000) + 30;
  save({ current:{ voteEndsAt: until, status:'voting' }});
};
elExtend.onclick = () => {
  const now = Math.floor(Date.now()/1000);
  const base = cache.current.voteEndsAt>now ? cache.current.voteEndsAt : now;
  save({ current:{ voteEndsAt: base + 15, status:'voting' }});
};
elEnd.onclick = () => save({ current:{ voteEndsAt: 0, status:'waiting' }});

document.querySelectorAll('.markBtn').forEach(btn=>{
  btn.onclick = async ()=>{
    const mark = btn.getAttribute('data-mark'); // Encore | Another Shot | Maybe Next Time
    const current = cache.current||{};
    if (!current.singer) return alert('No current singer set.');
    // update singer last result & optionally remove if Maybe Next Time
    const singers = (cache.singers||[]).map(s=>{
      if (s.name === current.singer) return {...s, last: mark };
      return s;
    }).filter(s => !(mark==='Maybe Next Time' && s.name===current.singer));
    const results = (cache.results||[]).slice();
    results.unshift({ ts: Date.now(), singer: current.singer, result: mark });
    const nextCurrent = { singer: current.singer, songArtist: current.songArtist||'', status: mark, voteEndsAt:0 };
    await save({ singers, results, current: nextCurrent });
  };
});

// Poll updates (so multiple host tabs stay in sync)
setInterval(load, 3000);

// initial
load();
</script>
</body>
</html>
