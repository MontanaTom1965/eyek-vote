<script>
(() => {
  // ===== Elements =====
  const els = {
    venue: document.getElementById('venue'),
    kj: document.getElementById('kj'),
    singer: document.getElementById('singerName'),
    song: document.getElementById('songArtist'),
    saveEventBtn: document.getElementById('saveEventBtn'),
    lockBtn: document.getElementById('lockBtn'),
    addSingerBtn: document.getElementById('addSingerBtn'),
    singersList: document.getElementById('singersList'),
    startBtn: document.getElementById('startVotingBtn'),
    extendBtn: document.getElementById('extendVotingBtn'),
    endBtn: document.getElementById('endVotingBtn'),
    // add whatever else you already have by id here if neededâ€¦
  };

  // Track which inputs are being edited so polling won't overwrite them
  const editing = { venue:false, kj:false, singer:false, song:false };

  // Simple debounce
  function debounce(fn, ms=300) {
    let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  }

  // Attach edit guards
  for (const [key, el] of Object.entries(els)) {
    if (!el || !['venue','kj','singer','song'].includes(key)) continue;
    el.addEventListener('focus', () => { editing[key] = true; });
    el.addEventListener('blur',  () => { editing[key] = false; });
    // Optional: live-validate or preview without saving
    el.addEventListener('input', debounce(() => {
      // no-op; keep for future live UI changes if wanted
    }, 200));
  }

  // ===== State & persistence =====
  let state = {
    event: { venue:'', kj:'', locked:false },
    current: { singer:'', song:'' },
    voting: { isOpen:false, endsAt:0, encore:0, shot:0, maybe:0 },
    singers: [] // [{name:'â€¦'}]
  };

  const STATUS_URL = '/assets/status.json'; // your existing path

  // Apply server state to form, but don't touch focused fields
  function applyStateToForm(s) {
    if (!editing.venue) els.venue && (els.venue.value = s.event?.venue || '');
    if (!editing.kj)    els.kj    && (els.kj.value    = s.event?.kj    || '');
    if (!editing.singer) els.singer && (els.singer.value = s.current?.singer || '');
    if (!editing.song)   els.song   && (els.song.value   = s.current?.song   || '');

    // Lock button label
    if (els.lockBtn) els.lockBtn.textContent = s.event?.locked ? 'Unlock Event' : 'Lock Event';

    // Sidebar singers
    if (els.singersList && Array.isArray(s.singers)) {
      els.singersList.innerHTML = '';
      s.singers.forEach((row, idx) => {
        const li = document.createElement('li');
        li.className = 'singer-row';
        li.innerHTML = `
          <span class="dot ${row.lastResult || ''}"></span>
          <span class="name">${row.name}</span>
          <span class="actions">
            <button class="set" data-idx="${idx}" aria-label="Set current">Set</button>
            <button class="remove" data-idx="${idx}" aria-label="Remove">ðŸ—‘</button>
          </span>`;
        els.singersList.appendChild(li);
      });
    }
  }

  // Fetch latest status (with cache-buster)
  async function fetchStatus() {
    try {
      const r = await fetch(`${STATUS_URL}?ts=${Date.now()}`);
      if (!r.ok) return;
      const newState = await r.json();
      state = newState;
      applyStateToForm(state);
    } catch (_) { /* ignore network blips */ }
  }

  // Save (POST) state to server endpoint (you already have whatever writes status.json)
  const saveState = debounce(async () => {
    try {
      await fetch('/assets/save_state.php', { // keep your existing endpoint
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify(state)
      });
    } catch (_) {}
  }, 250);

  // Wire up buttons to state changes
  if (els.saveEventBtn) {
    els.saveEventBtn.addEventListener('click', () => {
      state.event.venue = els.venue?.value?.trim() || '';
      state.event.kj    = els.kj?.value?.trim()    || '';
      saveState();
    });
  }
  if (els.lockBtn) {
    els.lockBtn.addEventListener('click', () => {
      state.event.locked = !state.event.locked;
      applyStateToForm(state); // update label instantly
      saveState();
    });
  }
  if (els.addSingerBtn) {
    els.addSingerBtn.addEventListener('click', () => {
      const name = (els.singer?.value || '').trim();
      const song = (els.song?.value   || '').trim();
      if (!name) return;
      state.singers.push({ name, lastResult: '' });
      // Do not jam song into sidebar; song stays in main section only
      saveState();
      // keep inputs for convenience, or clear if you prefer:
      // els.singer.value=''; els.song.value='';
    });
  }

  // Sidebar actions (Set current / Remove)
  document.addEventListener('click', (e) => {
    const setBtn = e.target.closest('button.set');
    const rmBtn  = e.target.closest('button.remove');
    if (setBtn) {
      const idx = +setBtn.dataset.idx;
      const row = state.singers[idx];
      if (row) {
        state.current.singer = row.name;
        // keep current song text area as typed; don't overwrite here
        saveState();
      }
    } else if (rmBtn) {
      const idx = +rmBtn.dataset.idx;
      state.singers.splice(idx, 1);
      saveState();
      applyStateToForm(state);
    }
  });

  // Voting controls: start / extend / end (just touching state; your existing PHP/JS tallies should read this)
  if (els.startBtn) {
    els.startBtn.addEventListener('click', () => {
      const now = Date.now();
      state.voting.isOpen = true;
      state.voting.endsAt = now + 30_000; // 30s
      // don't reset counts here if you want to carry host vote immediately
      saveState();
    });
  }
  if (els.extendBtn) {
    els.extendBtn.addEventListener('click', () => {
      if (state.voting.isOpen) {
        state.voting.endsAt += 15_000; // +15s
        saveState();
      }
    });
  }
  if (els.endBtn) {
    els.endBtn.addEventListener('click', () => {
      state.voting.isOpen = false;
      state.voting.endsAt = Date.now();
      saveState();
    });
  }

  // Host votes increment tallies (do not announce winners here)
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-host-vote]');
    if (!btn) return;
    const v = btn.getAttribute('data-host-vote'); // 'encore' | 'shot' | 'maybe'
    if (v && state.voting.isOpen) {
      state.voting[v] = (state.voting[v] || 0) + 1;
      saveState();
    }
  });

  // Poll server state periodically but DO NOT clobber focused inputs
  fetchStatus();                     // initial
  const poll = setInterval(fetchStatus, 2000); // every 2s

  // Optional: beforeunload to reduce chance of losing in-flight edits
  window.addEventListener('beforeunload', () => {
    // Try a last quick sync
    saveState.flush?.(); // if using a fancier debounce; harmless otherwise
    clearInterval(poll);
  });
})();
</script>
