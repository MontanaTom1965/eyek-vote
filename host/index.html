<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Earn Your Encore Karaoke — Host (Large Print)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store" />
  <style>
    /* ---------- ACCESSIBILITY FIRST ---------- */
    :root{
      --scale: 1;                 /* A- / A+ controls adjust this */
      --bg:#08090c; --panel:#0e1324; --card:#121831; --accent:#7bc4ff;
      --text:#ffffff; --muted:#c8d1e6; --border:#2a3553;
      --encore:#22c55e; --another:#f59e0b; --maybe:#ef4444;
      --btn:#1a2140; --btnBorder:#344062;
      --focus:#fff;
    }
    @media (prefers-contrast: more){
      :root{ --border:#41507a; --btnBorder:#4a5a8b; }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    html{background:var(--bg)}
    body{
      margin:0; min-height:100vh; display:flex; flex-direction:column;
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;
      font-size: calc(20px * var(--scale));  /* LARGE base type */
      line-height:1.35;
    }
    .wrap{max-width:1400px; margin:0 auto; width:100%}
    header{
      position:sticky; top:0; z-index:10;
      background:linear-gradient(180deg,rgba(8,9,12,.9),rgba(8,9,12,.6));
      backdrop-filter:saturate(1.2) blur(6px);
      border-bottom:2px solid var(--border);
    }
    .bar{
      display:flex; gap:16px; align-items:center; justify-content:space-between;
      padding:14px 18px;
    }
    .title{font-size:1.6em; font-weight:900; letter-spacing:.2px}
    .pill{display:inline-block; border:2px solid var(--border); border-radius:999px; padding:.25em .6em; color:var(--muted); font-weight:700}
    .row{display:grid; gap:18px; grid-template-columns:1fr 1fr}
    @media (max-width:1200px){ .row{grid-template-columns:1fr} }
    .card{
      background:var(--card); border:2px solid var(--border); border-radius:18px; padding:18px;
      box-shadow: 0 6px 24px rgba(0,0,0,.25);
    }
    h2{margin:.1em 0 .5em; font-size:1.4em}
    label{display:block; margin:.6em 0 .25em; font-weight:800}
    input{
      padding:.7em .8em; border-radius:12px; border:2px solid var(--border); width:100%;
      background:#0f152d; color:#fff; font-size:1.05em; outline:none;
    }
    input:focus{box-shadow:0 0 0 4px rgba(123,196,255,.25)}
    .stack{display:flex; gap:12px; flex-wrap:wrap}
    .btn{
      appearance:none; padding:.8em 1em; border:2px solid var(--btnBorder); border-radius:14px;
      background:var(--btn); color:#fff; font-weight:900; cursor:pointer; font-size:1.05em; letter-spacing:.25px;
      min-height:56px;
    }
    .btn:focus{outline:3px solid var(--focus); outline-offset:2px}
    .btn.primary{background:var(--accent); color:#07111d; border-color:#a9d9ff}
    .btn.good{background:var(--encore); color:#062; border-color:#70e395}
    .btn.warn{background:var(--another); color:#231b00; border-color:#ffd28a}
    .btn.danger{background:var(--maybe); color:#2b0000; border-color:#ffb4b4}
    .btn.ghost{background:#0f152d}
    .toggle{display:flex; gap:.5em; align-items:center; font-weight:800}
    .hint{color:var(--muted); font-weight:600}
    .bigline{font-size:1.3em; font-weight:900}
    ul{list-style:none; margin:0; padding:0}
    li{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:.7em .8em; border:2px solid var(--border); border-radius:14px;
      background:#0f152d; margin:.5em 0;
    }
    .qrWrap{
      background:#0e1220; border:2px dashed var(--border); border-radius:16px;
      display:flex; align-items:center; justify-content:center; padding:16px; min-height:520px;
    }
    .qrWrap img{ width:100%; height:auto; max-width:760px; border-radius:12px }
    footer{margin:12px 0 22px; color:var(--muted); text-align:center}
    .status{
      position:sticky; bottom:0; background:linear-gradient(180deg,rgba(8,9,12,.65),rgba(8,9,12,.95));
      border-top:2px solid var(--border); padding:12px 18px; font-weight:800;
    }
    .countdown{font-weight:900; font-size:1.4em}
    .controls .btn{min-width:220px}
    .sectionTitle{display:flex; align-items:center; justify-content:space-between; gap:12px}
    /* A-/A+ controls */
    .zoomControls .btn{min-width:0; padding:.5em .7em}
  </style>
</head>
<body>
  <header>
    <div class="wrap bar">
      <div class="title">Host Control</div>
      <div class="stack zoomControls" role="group" aria-label="Text size">
        <button class="btn ghost" id="zoomDown" title="Smaller text">A−</button>
        <span class="pill" id="zoomLabel">Text: 100%</span>
        <button class="btn ghost" id="zoomUp" title="Larger text">A+</button>
      </div>
    </div>
    <div class="wrap bar" style="padding-top:0">
      <div class="pill" id="eventPill">Event: —</div>
      <div class="stack">
        <label class="toggle"><input type="checkbox" id="broadcastActive"> Broadcast Active Event</label>
        <label class="toggle"><input type="checkbox" id="lockEvent"> Lock Event</label>
      </div>
    </div>
  </header>

  <main class="wrap" style="padding:18px">
    <!-- Event Controls -->
    <section class="card">
      <div class="sectionTitle">
        <h2>Event</h2>
      </div>
      <label for="eventId">Event name</label>
      <input id="eventId" placeholder="e.g. Eagles Nest" />
      <div class="stack" style="margin-top:.6em">
        <button class="btn primary" id="setEventBtn">Set / Switch Event</button>
        <button class="btn ghost" id="openScreen">Open Screen</button>
        <button class="btn ghost" id="openBoard">Open Board</button>
        <button class="btn ghost" id="copyEventVoteUrl">Copy Event Vote URL</button>
      </div>
      <div class="hint" id="eventNote" style="margin-top:.6em">TVs can open <code>/screen/</code> and <code>/board/</code> (no params) when Broadcast is ON.</div>
    </section>

    <div class="row" style="margin-top:18px">
      <!-- Now Performing + Controls -->
      <section class="card">
        <h2>Now Performing</h2>
        <div class="bigline" id="nowPerfLabel">None</div>
        <div class="hint" id="perfStatus">No performance yet</div>
        <div style="margin-top:.4em" class="hint">Countdown: <span class="countdown" id="countdown">—</span></div>
        <div class="stack controls" style="margin-top:12px">
          <button class="btn good"  id="btnAnnounce">Announce singer (show QR)</button>
          <button class="btn warn"  id="btnVoteNow">Vote now (30s)</button>
          <button class="btn ghost" id="btnExtend15">Extend +15s</button>
          <button class="btn danger" id="btnEndNow">End now</button>
        </div>
        <div class="stack" style="margin-top:12px">
          <button class="btn" id="hostVoteEncore"  style="background:var(--encore);color:#062">Host Vote: Encore</button>
          <button class="btn" id="hostVoteAnother" style="background:var(--another);color:#231b00">Host Vote: Another</button>
          <button class="btn" id="hostVoteMaybe"   style="background:var(--maybe)">Host Vote: Maybe</button>
        </div>
      </section>

      <!-- QR Panel -->
      <section class="card">
        <h2>Performance QR</h2>
        <div class="qrWrap"><img id="qrImg" alt="QR code" /></div>
        <div class="hint" id="perfVoteUrl" style="margin-top:.6em">—</div>
        <div class="stack" style="margin-top:.6em">
          <button class="btn ghost" id="copyPerfVoteUrl">Copy Perf Vote URL</button>
          <button class="btn ghost" id="openQrInNewTab">Open QR in New Tab</button>
        </div>
        <div class="hint" id="qrNote" style="margin-top:.4em"></div>
      </section>
    </div>

    <div class="row" style="margin-top:18px">
      <!-- Add/Choose Singer -->
      <section class="card">
        <h2>Add or choose singer</h2>
        <label for="singerName">Singer name</label>
        <input id="singerName" placeholder="Type a name, press Enter" />
        <div class="stack" style="margin-top:.6em">
          <button class="btn primary" id="addSingerBtn">Add Singer</button>
          <label class="toggle"><input type="checkbox" id="showHidden"> Show hidden (Maybe) singers</label>
        </div>
        <div class="hint" id="addSingerStatus" style="margin-top:.4em">Ready.</div>
      </section>

      <!-- Singer List -->
      <section class="card">
        <h2>Current singers</h2>
        <ul id="singerList"></ul>
        <div class="hint" id="singerReadNote"></div>
      </section>
    </div>
  </main>

  <div class="status">
    <div id="statusBar">Status: Idle…</div>
  </div>

  <footer class="wrap">
    <div class="hint">Tip: Use A− / A+ to resize everything. Big buttons are touch-friendly.</div>
  </footer>

  <!-- ======================= APP LOGIC ======================= -->
  <script type="module">
    /************** CONFIG **************/
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyDGbC08WxruYIDPhZSlDlU-7Kzq-7mHENk",
      authDomain: "eyek-vote.firebaseapp.com",
      projectId: "eyek-vote",
      storageBucket: "eyek-vote.firebasestorage.app",
      messagingSenderId: "954696683994",
      appId: "1:954696683994:web:21a84298a94648ff0230e3"
    };

    /************** IMPORTS **************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore, collection, addDoc, getDocs, deleteDoc,
      doc, setDoc, updateDoc, onSnapshot, query, where,
      serverTimestamp, Timestamp, getDoc
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    const app = initializeApp(FIREBASE_CONFIG);
    const db  = getFirestore(app);
    const auth = getAuth(app);

    // ---------- Anonymous sign-in (host) ----------
    signInAnonymously(auth).catch(e=>{
      setStatus("Auth error: " + (e?.message || e));
    });
    onAuthStateChanged(auth, user=>{
      if (!user) setStatus("Not signed in");
    });

    /************** DOM **************/
    const zoomDown = document.getElementById("zoomDown");
    const zoomUp = document.getElementById("zoomUp");
    const zoomLabel = document.getElementById("zoomLabel");

    const eventIdInput = document.getElementById("eventId");
    const eventPill    = document.getElementById("eventPill");
    const broadcastEl  = document.getElementById("broadcastActive");
    const lockEventEl  = document.getElementById("lockEvent");
    const eventNote    = document.getElementById("eventNote");

    const nowPerfLabel = document.getElementById("nowPerfLabel");
    const perfStatus   = document.getElementById("perfStatus");
    const countdownEl  = document.getElementById("countdown");

    const btnAnnounce  = document.getElementById("btnAnnounce");
    const btnVoteNow   = document.getElementById("btnVoteNow");
    const btnExtend15  = document.getElementById("btnExtend15");
    const btnEndNow    = document.getElementById("btnEndNow");

    const hostVoteEncore  = document.getElementById("hostVoteEncore");
    const hostVoteAnother = document.getElementById("hostVoteAnother");
    const hostVoteMaybe   = document.getElementById("hostVoteMaybe");

    const qrImg         = document.getElementById("qrImg");
    const perfVoteUrlEl = document.getElementById("perfVoteUrl");
    const qrNote        = document.getElementById("qrNote");
    const copyPerfVoteUrl = document.getElementById("copyPerfVoteUrl");
    const openQrInNewTab  = document.getElementById("openQrInNewTab");

    const openScreen = document.getElementById("openScreen");
    const openBoard  = document.getElementById("openBoard");
    const copyEventVoteUrl = document.getElementById("copyEventVoteUrl");

    const singerNameInput = document.getElementById("singerName");
    const addSingerBtn    = document.getElementById("addSingerBtn");
    const addSingerStatus = document.getElementById("addSingerStatus");
    const showHiddenEl    = document.getElementById("showHidden");
    const singerListEl    = document.getElementById("singerList");
    const singerReadNote  = document.getElementById("singerReadNote");

    const statusBar    = document.getElementById("statusBar");

    // Buttons
    document.getElementById("setEventBtn").addEventListener("click", onClickSetEvent);
    openScreen.addEventListener("click", ()=> window.open(urlRoot()+"screen/index.html?eventId="+encodeURIComponent(getCurrentEventId()), "_blank", "noopener"));
    openBoard.addEventListener("click",  ()=> window.open(urlRoot()+"board/index.html?eventId="+encodeURIComponent(getCurrentEventId()), "_blank", "noopener"));
    copyEventVoteUrl.addEventListener("click", ()=> {
      navigator.clipboard.writeText(urlRoot()+"vote/index.html?eventId="+encodeURIComponent(getCurrentEventId())).then(()=> setStatus("Event Vote URL copied."));
    });

    addSingerBtn.addEventListener("click", addSinger);
    singerNameInput.addEventListener("keydown", (e)=>{ if (e.key === "Enter") addSinger(); });

    btnAnnounce.addEventListener("click", announceSinger);
    btnVoteNow.addEventListener("click", ()=> openVoting(30));
    btnExtend15.addEventListener("click", ()=> extendVoting(15));
    btnEndNow.addEventListener("click", endVotingNow);

    hostVoteEncore.addEventListener("click", ()=> hostCastVote("encore"));
    hostVoteAnother.addEventListener("click", ()=> hostCastVote("another"));
    hostVoteMaybe.addEventListener("click", ()=> hostCastVote("maybe"));

    copyPerfVoteUrl.addEventListener("click", () => {
      const url = perfVoteUrlEl.textContent.trim();
      if (!url || url === "—") return setStatus("No performance.");
      navigator.clipboard.writeText(url).then(()=> setStatus("Performance Vote URL copied."));
    });
    openQrInNewTab.addEventListener("click", ()=>{
      const url = perfVoteUrlEl.textContent.trim();
      if (!url || url === "—") return setStatus("No performance.");
      window.open(qrProvider1(url), "_blank", "noopener");
    });

    broadcastEl.addEventListener("change", ()=> {
      localStorage.setItem("eyek_broadcast_event", broadcastEl.checked ? "1" : "0");
      if (broadcastEl.checked) broadcastActiveEvent(getCurrentEventId());
    });
    lockEventEl.addEventListener("change", ()=> {
      localStorage.setItem("eyek_lock_event", lockEventEl.checked ? "1" : "0");
      eventNote.textContent = lockEventEl.checked ? "Event locked — switching disabled." : "";
    });
    showHiddenEl.addEventListener("change", ()=> renderSingerList(cachedSingers));

    // Zoom controls
    const Z_KEY = "eyek_zoom";
    function setZoom(v){
      v = Math.min(1.6, Math.max(0.8, v));
      document.documentElement.style.setProperty("--scale", v);
      localStorage.setItem(Z_KEY, String(v));
      zoomLabel.textContent = "Text: " + Math.round(v*100) + "%";
    }
    zoomDown.addEventListener("click", ()=> setZoom((+localStorage.getItem(Z_KEY)||1) - 0.1));
    zoomUp.addEventListener("click",   ()=> setZoom((+localStorage.getItem(Z_KEY)||1) + 0.1));
    setZoom(+localStorage.getItem(Z_KEY)||1);

    /************** STATE **************/
    const STATE = { currentSingerId:null, currentSingerName:null, performanceId:null, performanceCloseAt:null, performanceStatus:"" };
    let unsubscribeSingers = null, unsubscribeState = null, unsubscribePerf = null;
    let countdownTimer = null, autoCloseTimer = null;
    const perfOutcomeCache = new Map(); // perfId -> outcome
    let cachedSingers = [];

    // Persisted event id
    const LS_EVENT = "eyek_last_event";

    // Prompt on first load if missing
    (function promptEventIfMissing(){
      const u = new URL(location.href);
      const q = u.searchParams.get("eventId");
      const mem = localStorage.getItem(LS_EVENT);
      if (!q && !mem){
        const typed = (prompt("Enter event name:") || "").trim();
        if (typed){
          u.searchParams.set("eventId", typed);
          history.replaceState({}, "", u.toString());
          localStorage.setItem(LS_EVENT, typed);
        }
      }
    })();

    // Init toggles
    broadcastEl.checked = localStorage.getItem("eyek_broadcast_event")==="1";
    lockEventEl.checked = localStorage.getItem("eyek_lock_event")==="1";
    if (lockEventEl.checked) eventNote.textContent = "Event locked — switching disabled.";

    // Start up on current/last event
    const START_EVENT = (new URL(location.href)).searchParams.get("eventId") || localStorage.getItem(LS_EVENT) || "default";
    eventIdInput.value = START_EVENT;
    applyEvent(START_EVENT);

    /************** Helpers **************/
    function setStatus(text){ statusBar.textContent = "Status: " + text; }
    function urlRoot(){ return location.origin + "/"; }
    function getCurrentEventId(){
      const u = new URL(window.location.href);
      const q = u.searchParams.get("eventId");
      if (q && q.trim()) return q.trim();
      const mem = localStorage.getItem(LS_EVENT);
      return mem && mem.trim() ? mem.trim() : "default";
    }
    function applyEvent(eid){
      const u = new URL(window.location.href);
      u.searchParams.set("eventId", eid);
      history.replaceState({}, "", u.toString());
      try{ localStorage.setItem(LS_EVENT, eid); }catch{}
      eventPill.textContent = "Event: " + eid;
      watchSingers(eid);
      watchState(eid);
      if (broadcastEl.checked) broadcastActiveEvent(eid);
      setStatus("Event set to: " + eid);
    }
    function onClickSetEvent(){
      const typed = (eventIdInput.value || "").trim();
      const current = getCurrentEventId();
      if (lockEventEl.checked) return setStatus("Event is locked. Uncheck ‘Lock Event’ to switch.");
      if (!typed) return setStatus("Enter an event name to set/switch.");
      if (typed === current) return setStatus(`Already on event “${current}”.`);
      const ok = confirm(`Switch event from “${current}” to “${typed}”?`);
      if (!ok) return setStatus("Event switch cancelled.");
      applyEvent(typed);
    }
    async function broadcastActiveEvent(eid){
      try{
        await setDoc(doc(db,"meta","active"), { eventId: eid, updatedAt: serverTimestamp() });
        eventNote.textContent = `Broadcasting Active Event: ${eid}`;
      }catch(e){
        eventNote.textContent = "Error broadcasting: " + (e?.message || e);
      }
    }

    // Device id for host vote
    function getDeviceId(){
      const KEY = "eyek_device_id";
      let id = localStorage.getItem(KEY);
      if (!id){
        const arr = new Uint8Array(16); crypto.getRandomValues(arr);
        id = Array.from(arr, b => b.toString(16).padStart(2,"0")).join("");
        localStorage.setItem(KEY, id);
      }
      return id;
    }
    const DEVICE_ID = getDeviceId();

    // QR providers (image-only so no extra JS libs)
    function qrProvider1(d){ return "https://api.qrserver.com/v1/create-qr-code/?size=700x700&data=" + encodeURIComponent(d); }
    function qrProvider2(d){ return "https://chart.googleapis.com/chart?cht=qr&chs=600x600&chl=" + encodeURIComponent(d); }
    function setQrImageForUrl(url){
      let tried=false;
      qrImg.onerror = ()=>{ if(!tried){ tried=true; qrImg.src = qrProvider2(url); qrNote.textContent = "Primary QR blocked; using fallback."; }else{ qrImg.alt="QR unavailable"; qrNote.textContent="Both QR providers blocked."; } };
      qrImg.src = qrProvider1(url);
    }
    function updatePerfQr(){
      const eid = getCurrentEventId();
      if (!STATE.performanceId){
        perfVoteUrlEl.textContent = "—"; qrImg.removeAttribute("src"); qrImg.alt="No performance"; qrNote.textContent=""; return;
      }
      const url = urlRoot() + "vote/index.html?eventId=" + encodeURIComponent(eid) + "&performanceId=" + encodeURIComponent(STATE.performanceId);
      perfVoteUrlEl.textContent = url;
      setQrImageForUrl(url);
      qrNote.textContent = "";
    }

    // Countdown
    function renderCountdown(){
      if (!STATE.performanceCloseAt || STATE.performanceStatus !== "open"){ countdownEl.textContent = "—"; return; }
      const ms = STATE.performanceCloseAt.toMillis() - Date.now();
      const s = Math.max(0, Math.ceil(ms/1000));
      countdownEl.textContent = s + "s";
    }
    function startCountdown(){ stopCountdown(); renderCountdown(); countdownTimer = setInterval(renderCountdown, 250); }
    function stopCountdown(){ if(countdownTimer){ clearInterval(countdownTimer); countdownTimer=null; } countdownEl.textContent="—"; }
    function armAutoClose(){
      if (autoCloseTimer){ clearTimeout(autoCloseTimer); autoCloseTimer=null; }
      if (!STATE.performanceCloseAt) return;
      const ms = Math.max(0, STATE.performanceCloseAt.toMillis() - Date.now());
      autoCloseTimer = setTimeout(()=> endVotingNow(), ms + 300);
    }

    // Watch state/performance
    function watchPerformance(eid, perfId){
      if (unsubscribePerf) unsubscribePerf();
      if (!perfId){
        STATE.performanceId=null; STATE.performanceCloseAt=null; STATE.performanceStatus="";
        stopCountdown(); updatePerfQr(); perfStatus.textContent = "No performance yet"; return;
      }
      unsubscribePerf = onSnapshot(doc(db,"events",eid,"performances",perfId),(snap)=>{
        if (!snap.exists()){ STATE.performanceCloseAt=null; STATE.performanceStatus=""; stopCountdown(); perfStatus.textContent = "(performance not found)"; return; }
        const d = snap.data()||{};
        STATE.performanceId = snap.id;
        STATE.performanceStatus = d.status || "pending";
        STATE.performanceCloseAt = d.closeAt || null;
        updatePerfQr();
        if (STATE.performanceStatus === "open"){ perfStatus.textContent = "Voting OPEN"; startCountdown(); armAutoClose(); }
        else if (STATE.performanceStatus === "pending"){ perfStatus.textContent = "Now singing (get ready)"; stopCountdown(); }
        else { perfStatus.textContent = "Voting CLOSED"; stopCountdown(); }
      }, (err)=> setStatus("Performance listener error: " + (err?.message || err)));
    }
    function watchState(eid){
      if (unsubscribeState) unsubscribeState();
      unsubscribeState = onSnapshot(doc(db,"events",eid,"state","current"), (snap)=>{
        if (!snap.exists()){ STATE.currentSingerId=null; STATE.currentSingerName=null; nowPerfLabel.textContent="None"; watchPerformance(eid, null); return; }
        const d = snap.data()||{};
        STATE.currentSingerId = d.currentSingerId || null;
        STATE.currentSingerName = d.currentSingerName || "(Unknown)";
        nowPerfLabel.textContent = STATE.currentSingerName || "None";
        watchPerformance(eid, d.performanceId || null);
      }, (err)=> setStatus("State listener error: " + (err?.message || err)));
    }

    // Singers list (hide 'maybe' by default)
    function renderSingerList(items){
      cachedSingers = items.slice();
      singerListEl.innerHTML = "";
      const showHidden = showHiddenEl.checked;

      items.sort((a,b)=> a.name.localeCompare(b.name, undefined, {sensitivity:"base"}));

      let shown = 0;
      for (const it of items){
        const perfId = it.latestPerformanceId || null;
        const outcome = perfId ? perfOutcomeCache.get(perfId) : null;

        if (!showHidden && outcome === 'maybe') continue;

        if (perfId && outcome === undefined){
          getDoc(doc(db,"events",getCurrentEventId(),"performances",perfId))
            .then(s=>{ perfOutcomeCache.set(perfId, s.exists() ? (s.data().outcome || null) : null); renderSingerList(cachedSingers); })
            .catch(()=>{ perfOutcomeCache.set(perfId,null); });
        }

        const li = document.createElement("li");
        const left = document.createElement("div");
        left.innerHTML = `<div style="font-weight:900">${it.name}</div><div class="hint">Latest: ${perfId || "—"} ${outcome ? `(${outcome})` : ""}</div>`;

        const right = document.createElement("div"); right.className = "stack";
        const b1 = document.createElement("button");
        b1.className = "btn good"; b1.textContent = "Announce";
        b1.addEventListener("click", ()=> announceExisting(it.id, it.name));

        const b2 = document.createElement("button");
        b2.className = "btn warn"; b2.textContent = "Vote now (30s)";
        b2.addEventListener("click", async ()=>{
          if (STATE.currentSingerId !== it.id){
            const ok = confirm(`Switch to “${it.name}” and open a 30s vote?`);
            if (!ok) return;
          }
          if (!STATE.performanceId || STATE.currentSingerId !== it.id){
            await announceExisting(it.id, it.name);
          }
          openVoting(30);
        });

        right.appendChild(b1); right.appendChild(b2);
        li.appendChild(left); li.appendChild(right);
        singerListEl.appendChild(li);
        shown++;
      }

      if (!shown){
        const li = document.createElement("li");
        li.textContent = showHidden ? "No singers." : "No singers (Maybe singers hidden).";
        singerListEl.appendChild(li);
      }
    }
    async function loadSingersOnce(eid){
      try{
        const snap = await getDocs(collection(db,"events",eid,"singers"));
        const items = snap.docs.map(d => ({ id:d.id, ...(d.data()||{}) }));
        renderSingerList(items); singerReadNote.textContent = "";
      }catch(e){
        renderSingerList([]); singerReadNote.textContent = "Could not read singers (check rules).";
      }
    }
    function watchSingers(eid){
      if (unsubscribeSingers) unsubscribeSingers();
      loadSingersOnce(eid);
      unsubscribeSingers = onSnapshot(query(collection(db,"events",eid,"singers")),(snap)=>{
        const items = []; snap.forEach(d=>{ const {name="", latestPerformanceId=null} = d.data()||{}; items.push({id:d.id, name, latestPerformanceId}); });
        renderSingerList(items); singerReadNote.textContent = "";
      }, (err)=>{ singerReadNote.textContent = "Realtime singers error: " + (err?.message || err); });
    }

    // Add singer (auto-announce)
    async function addSinger(){
      const name = singerNameInput.value.trim();
      if(!name) return addSingerStatus.textContent = "Please enter a singer name.";
      const eid = getCurrentEventId();
      try{
        if (!auth.currentUser) await signInAnonymously(auth);
      }catch(e){ addSingerStatus.textContent = "Auth error: " + (e?.message || e); return; }

      addSingerBtn.disabled = true; addSingerStatus.textContent = "Adding…";
      try{
        const ref = await addDoc(collection(db,"events",eid,"singers"), { name, ts: Date.now() });
        singerNameInput.value = "";
        addSingerStatus.textContent = "Singer added. Announcing…";
        await announceExisting(ref.id, name);
        addSingerStatus.textContent = "Singer added & announced.";
      }catch(e){
        const msg = (e && e.message) || String(e);
        addSingerStatus.textContent = msg.toLowerCase().includes("permission")
          ? "Permissions error adding singer (check rules)."
          : ("Error adding singer: " + msg);
      }finally{
        addSingerBtn.disabled = false;
      }
    }

    /************** Flow functions **************/
    async function announceExisting(singerId, singerName){
      const eid = getCurrentEventId();
      try{
        const perfRef = await addDoc(collection(db,"events",eid,"performances"), {
          singerId, singerName, status: 'pending', openAt: serverTimestamp()
        });
        await Promise.all([
          setDoc(doc(db,"events",eid,"singers",singerId), { latestPerformanceId: perfRef.id }, { merge:true }),
          setDoc(doc(db,"events",eid,"state","current"), {
            currentSingerId: singerId, currentSingerName: singerName, performanceId: perfRef.id, ts: Date.now()
          })
        ]);
        setStatus(`Announced: ${singerName}. QR shown; voting not open yet.`);
      }catch(e){ setStatus("Announce failed: " + (e?.message||e)); }
    }
    async function announceSinger(){
      if (!STATE.currentSingerId) return setStatus("Pick or add a singer first.");
      await announceExisting(STATE.currentSingerId, STATE.currentSingerName || "(Unknown)");
    }
    async function openVoting(seconds=30){
      const eid = getCurrentEventId();
      try{
        if (!STATE.performanceId){
          const perfRef = await addDoc(collection(db,"events",eid,"performances"), {
            singerId: STATE.currentSingerId, singerName: STATE.currentSingerName, status: 'pending', openAt: serverTimestamp()
          });
          await setDoc(doc(db,"events",eid,"singers",STATE.currentSingerId), { latestPerformanceId: perfRef.id }, { merge:true });
          await setDoc(doc(db,"events",eid,"state","current"), {
            currentSingerId: STATE.currentSingerId, currentSingerName: STATE.currentSingerName, performanceId: perfRef.id, ts: Date.now()
          });
        }
        const closeAt = Timestamp.fromMillis(Date.now() + seconds*1000);
        await updateDoc(doc(db,"events",eid,"performances",STATE.performanceId), {
          status: 'open', openAt: serverTimestamp(), closeAt
        });
        setStatus(`Voting opened for ${STATE.currentSingerName} (${seconds}s).`);
      }catch(e){ setStatus("Open voting error: " + (e?.message||e)); }
    }
    async function extendVoting(extra=15){
      const eid = getCurrentEventId();
      if (!STATE.performanceId) return setStatus("No performance.");
      try{
        const newClose = new Date(Math.max(Date.now(), (STATE.performanceCloseAt?.toMillis()||0)) + extra*1000);
        await updateDoc(doc(db,"events",eid,"performances",STATE.performanceId), { closeAt: Timestamp.fromDate(newClose) });
        setStatus(`Extended by ${extra}s.`);
      }catch(e){ setStatus("Extend failed: " + (e?.message||e)); }
    }
    function decideOutcome(e,a,m){
      e|=0; a|=0; m|=0;
      if (e>a && e>m) return 'encore';
      if (a>e && a>m) return 'another';
      if (m>e && m>a) return 'maybe';
      if (a===m && a>e) return 'another';
      if (e===a && e>m) return 'encore';
      if (e===m && e>a) return 'another';
      if (e===a && a===m && e>0) return 'another';
      return null;
    }
    async function finalizePerformance(eid, perfId){
      let e=0,a=0,m=0;
      try{
        const qref = query(collection(db,"events",eid,"votes"), where("performanceId","==",perfId));
        const snap = await getDocs(qref);
        snap.forEach(d=>{ const cat=(d.data()?.category||"").toLowerCase(); if(cat==='encore')e++; else if(cat==='another')a++; else if(cat==='maybe')m++; });
      }catch(_){}
      const outcome = decideOutcome(e,a,m);
      try{
        await updateDoc(doc(db,"events",eid,"performances",perfId), {
          status:'closed', closeAt: Timestamp.fromDate(new Date()), outcome, counts:{encore:e, another:a, maybe:m}
        });
        perfOutcomeCache.set(perfId, outcome || null);
        renderSingerList(cachedSingers);
      }catch(_){}
    }
    async function endVotingNow(){
      const eid = getCurrentEventId();
      if (!STATE.performanceId) return setStatus("No performance.");
      try{
        await updateDoc(doc(db,"events",eid,"performances",STATE.performanceId), { status:'closed', closeAt: Timestamp.fromDate(new Date()) });
        await finalizePerformance(eid, STATE.performanceId);
        setStatus("Voting closed.");
      }catch(e){ setStatus("End failed: " + (e?.message||e)); }
    }

    // Host vote (one per device per performance)
    async function hostCastVote(category){
      if (!STATE.performanceId) return setStatus("Open voting first.");
      const eid = getCurrentEventId();
      const docId = `${STATE.performanceId}__${DEVICE_ID}`;
      try{
        await setDoc(doc(db,"events",eid,"votes",docId), {
          performanceId: STATE.performanceId, singerId: STATE.currentSingerId, singerName: STATE.currentSingerName || "(Unknown)",
          category, deviceId: DEVICE_ID, ts: Date.now()
        }, { merge:false });
        setStatus("Host vote submitted.");
      }catch(e){
        const msg = (""+e?.message||"").toLowerCase();
        if (msg.includes("permission") || msg.includes("already exists")) setStatus("Already voted or window closed.");
        else setStatus("Error submitting vote.");
      }
    }

    // Watchers
    function watchSingers(eid){
      if (unsubscribeSingers) unsubscribeSingers();
      loadSingersOnce(eid);
      unsubscribeSingers = onSnapshot(query(collection(db,"events",eid,"singers")),(snap)=>{
        const items = []; snap.forEach(d=>{ const {name="", latestPerformanceId=null} = d.data()||{}; items.push({id:d.id, name, latestPerformanceId}); });
        renderSingerList(items); singerReadNote.textContent = "";
      }, (err)=>{ singerReadNote.textContent = "Realtime singers error: " + (err?.message || err); });
    }
    function watchState(eid){
      if (unsubscribeState) unsubscribeState();
      unsubscribeState = onSnapshot(doc(db,"events",eid,"state","current"), (snap)=>{
        if (!snap.exists()){ STATE.currentSingerId=null; STATE.currentSingerName=null; nowPerfLabel.textContent="None"; watchPerformance(eid, null); return; }
        const d = snap.data()||{};
        STATE.currentSingerId = d.currentSingerId || null;
        STATE.currentSingerName = d.currentSingerName || "(Unknown)";
        nowPerfLabel.textContent = STATE.currentSingerName || "None";
        watchPerformance(eid, d.performanceId || null);
      }, (err)=> setStatus("State listener error: " + (err?.message || err)));
    }
  </script>
</body>
</html>
